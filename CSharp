C# 1
-------------------------------------------------------------

C# 1.1
-------------------------------------------------------------

C# 2
-------------------------------------------------------------
2.1 匿名規則
委派可使用匿名規則 但之後可被LAMBDA取代
不過匿名規則提供LAMBDA運算沒有的功能
用執行緒的時候使用委派相關就很好用

Delegate只能使用Dowork(static function) 

Q LAMBDA 跟static FUNCTION差異?

2.2 NULL
T? 是 Nullable<T> 的縮寫
ex: int? test = null; (V)
int test = null; (X)

2.3 迭代器 / yield
foreach 會呼叫迭代器 MoveNext 每次都會在 yield return 先回傳 然後iterator 先暫存在當下 然後再繼續用
sample code : https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/yield

2.4 共變數/ 反變數
‧陣列類型、委派類型和泛型型別引數的隱含參考轉換

Q 奇怪這有點像 向上轉型 向下轉型 等
sample code : https://dotblogs.com.tw/daniel/2018/01/09/151636

C# 3
-------------------------------------------------------------
3.1 物件和集合初始設定式
- 新的匿名類型中的每個物件都有兩個公用屬性
Code: Cat cat = new Cat { Age = 10, Name = "Fluffy" };

Q 是好用，不過要寫INTERFACE

3.2 Lambda 運算式
LAMBDA運算式匿名凾式

Q非同步 LAMBDA ?
QFun / Action
Q區域Fun 跟 LAMBDA 差異：https://docs.microsoft.com/zh-tw/dotnet/csharp/local-functions-vs-lambdas
Qasync / Await : 使用方式
Qin/out差異

LAMBDA 吃的Variable會將外部的copy一份，而不是直接使用。
Q 委派符合記憶體回收的資格 ?
使用參數 ( params / in / out )
params: 方便待參數 可LIST
in: 4.5.1 也還不行用，要等到更新版 ? - 好處是call by reference效率較高，不須重新create 適合大資訊
out/ref:ref 需要在執行前初始化參數(給值)而 out 是在程式結束前需要初始化參數(給值)

3.3 擴充方法
擴充方法可讓您在現有類型中「加入」方法，而不需要建立新的衍生類型、重新編譯，或是修改原始類型。
public static int WordCount(this String str){ } // 蠻猛的用 this
// 然後可以使用 xx.WordCount() 來使用

3.4 匿名類型
---
var v = new { Amount = 108, Message = "Hello" };  

// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
---
無法轉型 - 匿名型別是直接衍生自 object，並且無法轉換成 object 以外之任何類型的 class 類型。

3.5 自動屬性
class Customer
{
    // Auto-Impl Properties for trivial get and set
    public double TotalPurchases { get; set; }
    public string Name { get; set; }
}

3.6 VAR

3.7 Language Integrated Query (LINQ)
「查詢運算式」以及撰寫為「方法查詢」的語意對等查詢。
        //Query syntax:
        IEnumerable<int> numQuery1 = 
            from num in numbers
            where num % 2 == 0
            orderby num
            select num;

        //Method syntax:
        IEnumerable<int> numQuery2 = numbers.Where(num => num % 2 == 0).OrderBy(n => n);
 Where 會產生已篩選的序列，而 Orderby 接著會透過排序來運作於該序列。因為查詢會傳回 IEnumerable，所以您可以將方法呼叫鏈結在一起。
 使用參考：https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/concepts/linq/standard-query-operators-overview

