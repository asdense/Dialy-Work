釐清 CLR、.NET、C#、Visual Studio、ASP.NET 各版本之間的關係，名詞解釋；很重要
https://blog.miniasp.com/post/2015/07/28/Clarify-the-versions-between-CLR-NET-CSharp-Visual-Studio-and-ASPNET.aspx

C# 1
-------------------------------------------------------------

C# 1.1
-------------------------------------------------------------

C# 2
-------------------------------------------------------------
2.1 匿名規則
委派可使用匿名規則 但之後可被LAMBDA取代
不過匿名規則提供LAMBDA運算沒有的功能
用執行緒的時候使用委派相關就很好用

Delegate只能使用Dowork(static function) 

Q LAMBDA 跟static FUNCTION差異?

2.2 NULL
T? 是 Nullable<T> 的縮寫
ex: int? test = null; (V)
int test = null; (X)

2.3 迭代器 / yield
foreach 會呼叫迭代器 MoveNext 每次都會在 yield return 先回傳 然後iterator 先暫存在當下 然後再繼續用
sample code : https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/yield

2.4 共變數/ 反變數
‧陣列類型、委派類型和泛型型別引數的隱含參考轉換

Q 奇怪這有點像 向上轉型 向下轉型 等
sample code : https://dotblogs.com.tw/daniel/2018/01/09/151636

C# 3
-------------------------------------------------------------
3.1 物件和集合初始設定式
- 新的匿名類型中的每個物件都有兩個公用屬性
Code: Cat cat = new Cat { Age = 10, Name = "Fluffy" };

Q 是好用，不過要寫INTERFACE

3.2 Lambda 運算式
LAMBDA運算式匿名凾式

Q非同步 LAMBDA ?
QFun / Action
Q區域Fun 跟 LAMBDA 差異：https://docs.microsoft.com/zh-tw/dotnet/csharp/local-functions-vs-lambdas
Qasync / Await : 使用方式
Qin/out差異

LAMBDA 吃的Variable會將外部的copy一份，而不是直接使用。
Q 委派符合記憶體回收的資格 ?
使用參數 ( params / in / out )
params: 方便待參數 可LIST
in: 4.5.1 也還不行用，要等到更新版 ? - 好處是call by reference效率較高，不須重新create 適合大資訊
out/ref:ref 需要在執行前初始化參數(給值)而 out 是在程式結束前需要初始化參數(給值)

3.3 擴充方法
擴充方法可讓您在現有類型中「加入」方法，而不需要建立新的衍生類型、重新編譯，或是修改原始類型。
public static int WordCount(this String str){ } // 蠻猛的用 this
// 然後可以使用 xx.WordCount() 來使用

3.4 匿名類型
---
var v = new { Amount = 108, Message = "Hello" };  

// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
---
無法轉型 - 匿名型別是直接衍生自 object，並且無法轉換成 object 以外之任何類型的 class 類型。

3.5 自動屬性
class Customer
{
    // Auto-Impl Properties for trivial get and set
    public double TotalPurchases { get; set; }
    public string Name { get; set; }
}

3.6 VAR

3.7 Language Integrated Query (LINQ)
「查詢運算式」以及撰寫為「方法查詢」的語意對等查詢。
        //Query syntax:
        IEnumerable<int> numQuery1 = 
            from num in numbers
            where num % 2 == 0
            orderby num
            select num;

        //Method syntax:
        IEnumerable<int> numQuery2 = numbers.Where(num => num % 2 == 0).OrderBy(n => n);
 Where 會產生已篩選的序列，而 Orderby 接著會透過排序來運作於該序列。因為查詢會傳回 IEnumerable，所以您可以將方法呼叫鏈結在一起。
 使用參考：https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/concepts/linq/standard-query-operators-overview
 
--查詢作業的三個部分
所有的 LINQ 查詢作業都包含三個不同的動作：
1.取得資料來源。
2.建立查詢。
3.執行查詢。

C# 4
-------------------------------------------------------------
4.1 dynamic 
compiler 不會出現錯誤 / runtime 執行時候才會出錯 

Dynamic Language Runtime
Dynamic Language Runtime (DLR) 是 .NET Framework 4 中的新 API。 它提供的基礎結構支援 C# 中的 dynamic 類型，也支援實作 IronPython 和 IronRuby 之類的動態程式設計語言。

4.2 具名引數Named Arguments
void PrintOrderDetails(string sellerName, int orderNum, string productName) { }
PrintOrderDetails("Gift Shop", 31, productName: "Red Mug");  // 使用具名引數 productName

4.3選擇性參數及泛型共變數/反變數
https://msdn.microsoft.com/zh-tw/library/dd799517(v=vs.100).aspx ?
複雜


C# 5
-------------------------------------------------------------
1. Async / await
編譯器會代替開發人員處理過去經常要處理的困難工作

async 和 await 關鍵字不會導致建立其他執行緒。 由於非同步方法不會在本身的執行緒上執行，因此非同步方法不需要多執行緒。 
方法會在目前的同步處理內容執行，而且只有在方法為作用中時才會在執行緒上花費時間。 
您可以使用 Task.Run 將受限於 CPU 的工作移到背景執行緒，但是背景執行緒無法協助處理正在等待結果產生的處理序。

async 有分 thread 沒開的話也會擋ui。
https://dotblogs.com.tw/yc421206/archive/2013/06/14/105482.aspx
# 參考c# 的sample 自己寫的

2. 呼叫者資訊屬性
 您可以取得原始程式碼的檔案路徑、原始程式碼中的行號，以及呼叫端的成員名稱。 這項資訊有助於追蹤、偵錯及建立診斷工具。

Visual Studio .NET 2013：
-------------------------------------------------------------
此版 Visual Studio 包括 Bug 修正、效能改進，以及 .NET Compiler Platform ("Roslyn") (後來成為 .NET Compiler Platform SDK) 的技術預覽。

跨平台支援：
-------------------------------------------------------------
透過 .NET Core 支援，C# 可在多種平台上執行。 如果您有興趣在 macOS 或是其中一個支援的 Linux 發行版本上嘗試 C#，請深入了解 .NET Core。

.NET 編譯器平台 SDK：
-------------------------------------------------------------
.NET 編譯器平台 SDK 讓您能夠撰寫對 C# 程式碼執行靜態分析的程式碼。 您可以使用這些 API 找出可能的錯誤 (或是不正確的做法)、建議修正程式，甚至實作那些修正程式。

\*
\* C# 5.0 搭配 .NET Framework4.5.2 <---- Visual Studio 2013版 最多只能支援到 .NET Framework4.6
\*

C# 6
-------------------------------------------------------------
6.1 針對屬性做動作，private
public Standing YearInSchool { get; set; } = Standing.Freshman;

6.2 使用using static xxx => use this namespace all static function

6.3 NULL 條件運算子 ?.
var first = person?.FirstName;  如果person = null, first = null

6.4 字串插值 ( 前面加上$ )
public string FullName => $"{FirstName} {LastName}";

// LINQ +
public string GetAllGrades() =>
    $@"All Grades: {Grades.OrderByDescending(g => g)
    .Select(s => s.ToString("F2")).Aggregate((partial, element) => $"{partial}, {element}")}";

6.5 例外篩選條件 
多了一個when
 try
        {
            var responseText = await stringTask;
            return responseText;
        }
        catch (System.Net.Http.HttpRequestException e) when (e.Message.Contains("301"))
        {
            return "Site Moved";
        }

------
        int nTest = 5;
        nTest.test();
        public static bool test(this int e)
        {
            return true;
        }



Q 正規 需要用到
